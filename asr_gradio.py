import gradio as gr
import os
import tempfile
import logging
from pathlib import Path
from typing import List, Optional
import json
import time
from BcutASR import BcutASR

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

class ASRGradioApp:
    def __init__(self):
        self.supported_formats = ['.mp3', '.wav', '.m4a', '.flac', '.aac', '.mp4', '.avi', '.mov', '.mkv']
        
    def process_single_file(self, file_path: str, output_format: str) -> tuple:
        """处理单个文件，返回处理结果和文件路径"""
        try:
            logging.info(f"开始处理文件: {file_path}")
            
            # 使用BcutASR进行语音识别
            asr = BcutASR(file_path)
            asr_data = asr.run()
            
            # 生成输出文件路径
            input_path = Path(file_path)
            output_path = input_path.with_suffix(f'.{output_format.lower()}')
            
            # 根据格式生成输出内容
            if output_format.upper() == 'SRT':
                content = self._generate_srt(asr_data)
            elif output_format.upper() == 'TXT':
                content = self._generate_txt(asr_data)
            elif output_format.upper() == 'ASS':
                content = self._generate_ass(asr_data)
            else:
                content = self._generate_txt(asr_data)
            
            # 写入文件
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logging.info(f"处理完成: {output_path}")
            return f"处理成功！输出文件: {output_path}", str(output_path)
            
        except Exception as e:
            logging.error(f"处理文件失败: {str(e)}")
            return f"处理失败: {str(e)}", None
    
    def process_multiple_files(self, files: List[str], output_format: str) -> str:
        """处理多个文件"""
        results = []
        total_files = len(files)
        
        for i, file_path in enumerate(files, 1):
            logging.info(f"处理文件 {i}/{total_files}: {file_path}")
            try:
                result = self.process_single_file(file_path, output_format)
                results.append(f"{i}. {file_path}: {result}")
            except Exception as e:
                results.append(f"{i}. {file_path}: 处理失败 - {str(e)}")
        
        return "\n".join(results)
    
    def _generate_srt(self, asr_data) -> str:
        """生成SRT字幕格式"""
        srt_content = []
        for i, segment in enumerate(asr_data.segments, 1):
            start_time = self._format_timestamp(segment.start)
            end_time = self._format_timestamp(segment.end)
            srt_content.append(f"{i}\n{start_time} --> {end_time}\n{segment.text}\n")
        return "\n".join(srt_content)
    
    def _generate_txt(self, asr_data) -> str:
        """生成TXT文本格式"""
        return "\n".join([segment.text for segment in asr_data.segments])
    
    def _generate_ass(self, asr_data) -> str:
        """生成ASS字幕格式"""
        ass_header = """[Script Info]
Title: Generated by ASR Tools
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
        
        ass_events = []
        for segment in asr_data.segments:
            start_time = self._format_ass_timestamp(segment.start)
            end_time = self._format_ass_timestamp(segment.end)
            ass_events.append(f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{segment.text}")
        
        return ass_header + "\n".join(ass_events)
    
    def _format_timestamp(self, seconds: float) -> str:
        """格式化时间戳为SRT格式"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds - int(seconds)) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"
    
    def _format_ass_timestamp(self, seconds: float) -> str:
        """格式化时间戳为ASS格式"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        centisecs = int((seconds - int(seconds)) * 100)
        return f"{hours}:{minutes:02d}:{secs:02d}.{centisecs:02d}"

def create_interface():
    """创建Gradio界面"""
    app = ASRGradioApp()
    
    with gr.Blocks(title="ASR Tools - 语音识别工具", theme=gr.themes.Soft()) as demo:
        gr.Markdown("""
        # 🎤 ASR Tools - 智能语音识别工具
        
        基于必剪ASR接口的高效语音识别工具，支持多种音频/视频格式和输出格式。
        """)
        
        with gr.Row():
            with gr.Column():
                file_input = gr.File(
                    label="选择音频/视频文件",
                    file_count="multiple",
                    file_types=app.supported_formats
                )
                
                output_format = gr.Dropdown(
                    choices=["SRT", "TXT", "ASS"],
                    label="输出格式",
                    value="SRT",
                    info="选择字幕输出格式"
                )
                
                process_btn = gr.Button("开始处理", variant="primary")
            
            with gr.Column():
                output_text = gr.Textbox(
                    label="处理结果",
                    lines=10,
                    max_lines=20,
                    placeholder="处理结果将显示在这里..."
                )
                
                download_file = gr.File(
                    label="下载生成的文件"
                )
        

        # 处理逻辑
        def process_files(files, format_choice):
            if not files:
                return "请先选择文件", None
            
            file_paths = [file.name for file in files]
            
            if len(file_paths) == 1:
                result, file_path = app.process_single_file(file_paths[0], format_choice)
                return result, file_path
            else:
                result = app.process_multiple_files(file_paths, format_choice)
                return result, None
        
        process_btn.click(
            fn=process_files,
            inputs=[file_input, output_format],
            outputs=[output_text, download_file]
        )
    
    return demo

if __name__ == "__main__":
    # 创建并启动界面
    demo = create_interface()
    demo.launch(
        server_name="0.0.0.0",
        server_port=8080,
        share=False,
        show_error=True,
        debug=True
    )
